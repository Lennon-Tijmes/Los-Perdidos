#include <Arduino.h>

// Motor Pins
#define MOTOR_LEFT_FWD 10
#define MOTOR_LEFT_BWD 11
#define MOTOR_RIGHT_FWD 9
#define MOTOR_RIGHT_BWD 3

// Sensor Pins
const unsigned char TRACK_SENSORS[] = {A7, A6, A5, A4, A3, A2, A1, A0};  // 8 sensors
int sensorReadings[8] = {0, 0, 0, 0, 0, 0, 0, 0};

// Thresholds for black and white detection
unsigned int thresholdBlack = 800;  // Adjust this for your robot's sensors
unsigned int thresholdWhite = 600;  // Adjust this for your robot's sensors

// Speed Control
#define SPEED_LEFT_FULL 255
#define SPEED_RIGHT_FULL 255
#define SPEED_LEFT_HALF 130
#define SPEED_RIGHT_HALF 130
#define SPEED_STOP 0

// Robot states
enum RobotState { HALT, MOVE_AHEAD, SEARCH_RIGHT, SEARCH_LEFT };
RobotState currentRobotState = HALT;

void initializeHardware() {
  pinMode(MOTOR_LEFT_FWD, OUTPUT);
  pinMode(MOTOR_LEFT_BWD, OUTPUT);
  pinMode(MOTOR_RIGHT_FWD, OUTPUT);
  pinMode(MOTOR_RIGHT_BWD, OUTPUT);

  Serial.begin(9600);

  for (char i = 0; i < 8; i++) {
    pinMode(TRACK_SENSORS[i], INPUT);
  }
}

void readTrackSensors();
void moveStraight();
void haltMotors();
void turnRobotRight();
void turnRobotLeft();
void handleLineTracking();
void handleStateTransition();

void setup() {
  initializeHardware();
}

void loop() {
  readTrackSensors();
  handleLineTracking();
  handleStateTransition();
}

void readTrackSensors() {
  for (unsigned char i = 0; i < 8; i++) {
    sensorReadings[i] = analogRead(TRACK_SENSORS[i]);
  }

  // Debugging output to check sensor values
  Serial.print("Sensor Values: ");
  for (unsigned char i = 0; i < 8; i++) {
    Serial.print(sensorReadings[i]);
    Serial.print(" ");
  }
  Serial.println();
}

void moveStraight() {
  analogWrite(MOTOR_LEFT_FWD, SPEED_LEFT_FULL);
  analogWrite(MOTOR_LEFT_BWD, SPEED_STOP);
  analogWrite(MOTOR_RIGHT_FWD, SPEED_RIGHT_FULL);
  analogWrite(MOTOR_RIGHT_BWD, SPEED_STOP);
}

void haltMotors() {
  analogWrite(MOTOR_LEFT_FWD, SPEED_STOP);
  analogWrite(MOTOR_LEFT_BWD, SPEED_STOP);
  analogWrite(MOTOR_RIGHT_FWD, SPEED_STOP);
  analogWrite(MOTOR_RIGHT_BWD, SPEED_STOP);
}

void turnRobotRight() {
  analogWrite(MOTOR_LEFT_FWD, SPEED_LEFT_HALF);
  analogWrite(MOTOR_LEFT_BWD, SPEED_STOP);
  analogWrite(MOTOR_RIGHT_FWD, SPEED_STOP);
  analogWrite(MOTOR_RIGHT_BWD, SPEED_RIGHT_HALF);
}

void turnRobotLeft() {
  analogWrite(MOTOR_RIGHT_FWD, SPEED_RIGHT_HALF);
  analogWrite(MOTOR_RIGHT_BWD, SPEED_STOP);
  analogWrite(MOTOR_LEFT_FWD, SPEED_STOP);
  analogWrite(MOTOR_LEFT_BWD, SPEED_LEFT_HALF);
}

void handleLineTracking() {
  bool anyBlackDetected = false;

  // Check all sensors to see if any sensor detects black
  for (char i = 0; i < 8; i++) {
    if (sensorReadings[i] >= thresholdBlack) {
      anyBlackDetected = true;
      break;  // If one sensor detects black, stop checking the rest
    }
  }

  if (anyBlackDetected) {
    moveStraight();  // Move straight if any sensor detects black
    currentRobotState = MOVE_AHEAD;
  } else {
    currentRobotState = SEARCH_RIGHT;  // If no black detected, search for the line
    
    if (anyBlackDetected) {
      moveStraight();  // Move straight if any sensor detects black
      currentRobotState = MOVE_AHEAD;
      
      }else {
      currentRobotState = SEARCH_LEFT;
      
      }
  }
}


void handleStateTransition() {
  switch (currentRobotState) {
    case SEARCH_RIGHT:
      turnRobotRight();  // Rotate right to search for the line
      delay(200);  // Rotate right for a short time
      break;

    case SEARCH_LEFT:
      turnRobotLeft();  // Rotate left to search for the line
      delay(200);  // Rotate left for a short time
      break;

    case MOVE_AHEAD:
      // Do nothing since we're already moving straight
      break;


  }
}


